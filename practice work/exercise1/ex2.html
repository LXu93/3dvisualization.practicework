<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Ex2</title>
    <style>
       html, body {
        height: 100%;
        margin: 0;
    }
    #canvas1,#cavas2 {
        width: 100%;
        height: 100%;
        display: block;
    }
    </style>
  <body>
  <canvas id="canvas1"></canvas>
  <canvas id="canvas2"></canvas>
  </body>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
  import { FlyControls } from 'three/addons/controls/FlyControls.js';
  import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

let renderer, camera,  scene,camera2,renderer2;
let OBControls, FPControls, flyControls, tbControls;
let lastTime=0

init()
main()
function init() 
{
scene = new THREE.Scene();
scene.background = new THREE.Color( 0x333333 );
camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
scene.add(camera);
const canvas = document.getElementById("canvas1");
renderer = new THREE.WebGLRenderer({canvas,antialias:true});



renderer.setSize( window.innerWidth, window.innerHeight );

camera.up.set(0,0,1);
camera.lookAt(0,0,0);
camera.position.set(0,-100,100);



camera2 = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
scene.add(camera2)

const canvas2 = document.getElementById("canvas2");
renderer2 = new THREE.WebGLRenderer({canvas2,antialias:true});

renderer2.setSize( window.innerWidth, window.innerHeight );

camera2.up.set(0,0,1);
camera2.lookAt(0,0,0);
camera2.position.set(0,-100,100);

//OBControls = new OrbitControls( camera, renderer.domElement );
//OBControls.listenToKeyEvents( window ); // optional

FPControls = new FirstPersonControls(camera, renderer2.domElement);
flyControls = new FlyControls(camera,renderer.domElement);
tbControls = new TrackballControls(camera,renderer.domElement);



  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
    scene.add(light);
  }

  {
  const color = 0xFFFFFF;  // white
  const near = 10;
  const far = 50;
  scene.fog = new THREE.Fog(color, near, far);
}
}

function main(){
  createMarks();

  requestAnimationFrame(render);
}

function createMarks(){
  const material = new THREE.LineBasicMaterial({
	color: 0xffffff
});

const points = [];
points.push( new THREE.Vector3( - 1, 0, 0 ) );
points.push( new THREE.Vector3( 1, 0, 0 ) );

const lineGeometry = new THREE.BufferGeometry().setFromPoints( points );

const horizontalLine = new THREE.Line( lineGeometry, material );
const verticalLine = horizontalLine.clone();
verticalLine.rotation.z = Math.PI/2;

const cross = new THREE.Group();
cross.add(horizontalLine);
cross.add(verticalLine);
scene.add( cross );

for (let i=-100;i<=100;i=i+4){
  for(let j=-100;j<=100;j=j+4){
    const mark = cross.clone();
    scene.add(mark);
    mark.position.set(i,j,0);
  }  
}

}
function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }
  
function render(time) {
  //time *= 0.0004;
  const deltaTime = time-lastTime;
  lastTime = time;
  
  

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }
    
    renderer.render(scene, camera);
    renderer2.render(scene,camera2)
    //renderer2.render(scene,camere2);
    //flyControls.update(deltaTime*0.05);
    FPControls.update(deltaTime*0.05);
    tbControls.update();

   
    requestAnimationFrame(render);
  }

</script>
</html>