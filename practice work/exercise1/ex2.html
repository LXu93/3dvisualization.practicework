<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Ex2</title>
    <style>
      html, body {
          height: 100%;
          margin: 0;
      }
      #c {
          width: 100%;
          height: 100%;
          display: block;
      }
      </style>
    </head>
    <body>
      <canvas id="c">
        <p>Perspective Camera</p>
        <p>Orthographic Camera</p>
      </canvas>
    </body>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
  import { FlyControls } from 'three/addons/controls/FlyControls.js';
  import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

let canvas, renderer, scene, scene2;
let cameraPerpective,   cameraOrthograpic, cameraPerpective2,   cameraOrthograpic2 ;
let OBControls, FPControls, flyControls, tbControls;
let lastTime=0;

init()
main()
function init() 
{
scene = new THREE.Scene();
scene.background = new THREE.Color( 0x333333 );
const axesHelper = new THREE.AxesHelper( 10 );
scene.add( axesHelper );
{
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.SpotLight(color, intensity);
    light.position.set(0,0,100);
    scene.add(light);
  }

  {
  const color = 0xFFFFFF;  // white
  const near = 10;
  const far = 50;
  scene.fog = new THREE.Fog(color, near, far);
}

canvas = document.getElementById("c");
renderer = new THREE.WebGLRenderer({canvas,antialias:true});
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setScissorTest(true);

cameraPerpective = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
scene.add(cameraPerpective);
cameraPerpective.position.set(20,20,20);

cameraOrthograpic = new THREE.OrthographicCamera( -30, 30, -30, 30, 1, 1000);
scene.add(cameraOrthograpic);
cameraOrthograpic.position.set(20,20,20);

cameraPerpective2 = cameraPerpective.clone();
scene.add(cameraPerpective2);

cameraOrthograpic2 = cameraOrthograpic.clone();
scene.add(cameraOrthograpic2);


OBControls = new OrbitControls( cameraPerpective, renderer.domElement );
FPControls = new FirstPersonControls(cameraPerpective2, renderer.domElement);
FPControls.heightMax = 0.6;
FPControls.heightMin = 0.4;
FPControls.movementSpeed = 0.5;
FPControls.rollSpeed = 0.001;



flyControls = new FlyControls(cameraOrthograpic,renderer.domElement);
flyControls.movementSpeed = 0.5;
flyControls.rollSpeed = 0.001;

tbControls = new TrackballControls(cameraOrthograpic2, renderer.domElement);

OBControls.enabled = false;
FPControls.enabled = false;
flyControls.enabled = false;
tbControls.enabled = false;

 
}

function main(){
  createMarks(scene,1,4,100);
  requestAnimationFrame(render);
}

function createMarks(scene, size, distance, number){
  const material = new THREE.LineBasicMaterial({
	color: 0x666666
});

const points = [];
points.push( new THREE.Vector3( - size/2, 0, 0 ) );
points.push( new THREE.Vector3( size/2, 0, 0 ) );

const lineGeometry = new THREE.BufferGeometry().setFromPoints( points );

const horizontalLine = new THREE.Line( lineGeometry, material );
const verticalLine = horizontalLine.clone();
verticalLine.rotation.y = Math.PI/2;

const cross = new THREE.Group();
cross.add(horizontalLine);
cross.add(verticalLine);

const length = (number-1)*(size+distance);
for (let i=-length/2;i<=length/2;i=i+distance+size){
  for(let j=-length/2;j<=length/2;j=j+distance+size){
    const mark = cross.clone();
    scene.add(mark);
    mark.position.set(i,0,j);
  }  
}
}

function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }
  
function render(time) {
  //time *= 0.0004;
  const deltaTime = time-lastTime;
  lastTime = time;
  

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      cameraPerpective.aspect = canvas.clientWidth / canvas.clientHeight;
      cameraPerpective.updateProjectionMatrix();
      cameraPerpective2.aspect = canvas.clientWidth / canvas.clientHeight;
      cameraPerpective2.updateProjectionMatrix();
    }
    
  renderer.setScissor(0, 0, window.innerWidth / 2, window.innerHeight/2 );
  renderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight/2 );
  renderer.render(scene, cameraPerpective2);
 

  renderer.setScissor(0,window.innerHeight/2, window.innerWidth / 2, window.innerHeight/2 );
  renderer.setViewport(0, window.innerHeight/2, window.innerWidth / 2, window.innerHeight/2 );
  renderer.render(scene, cameraPerpective);


  renderer.setScissor(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight/2);
  renderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight/2);
  renderer.render(scene, cameraOrthograpic2);

  renderer.setScissor(window.innerWidth / 2, window.innerHeight/2, window.innerWidth / 2, window.innerHeight/2);
  renderer.setViewport(window.innerWidth / 2, window.innerHeight/2,  window.innerWidth / 2, window.innerHeight/2);
  renderer.render(scene, cameraOrthograpic);
    
  canvas.addEventListener('mousemove', (event) => {
  if (event.clientX <  window.innerWidth / 2 && event.clientY < window.innerHeight / 2){
    OBControls.enabled = true;
    //FPControls.enabled = false;
    flyControls.enabled = false;
    tbControls.enabled = false;
    
  }else if(event.clientX <  window.innerWidth / 2 && event.clientY > window.innerHeight / 2){
    OBControls.enabled = false;
    FPControls.enabled = true;
    flyControls.enabled = false;
    tbControls.enabled = false;
  }else if(event.clientX >  window.innerWidth / 2 && event.clientY < window.innerHeight / 2){
    OBControls.enabled = false;
    FPControls.enabled = false;
    flyControls.enabled = true;
    tbControls.enabled = false;
  }else{
    OBControls.enabled = false;
    //FPControls.enabled = false;
    flyControls.enabled = false;
    tbControls.enabled = true;
  }
});
    flyControls.update(deltaTime*0.008);
    FPControls.update(deltaTime*0.008);
    tbControls.update();

   
    requestAnimationFrame(render);
  }

</script>
</html>