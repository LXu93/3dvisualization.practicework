<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Ex2</title>
    <style>
      html, body {
          height: 100%;
          margin: 0;
      }
      #c {
          width: 100%;
          height: 100%;
          display: block;
      }
      </style>
    </head>
    <body>
      <canvas id="c">
        <p>Perspective Camera</p>
        <p>Orthographic Camera</p>
      </canvas>
    </body>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
  import { FlyControls } from 'three/addons/controls/FlyControls.js';
  import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

let renderer, scene, cameraPerpective,   cameraOrthograpic, canvas;
let OBControls, FPControls, flyControls, tbControls;
let lastTime=0;

init()
main()
function init() 
{
scene = new THREE.Scene();
scene.background = new THREE.Color( 0x333333 );

canvas = document.getElementById("c");
renderer = new THREE.WebGLRenderer({canvas,antialias:true});
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setScissorTest(true);

cameraPerpective = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
scene.add(cameraPerpective);
cameraPerpective.up.set(0,0,1);
cameraPerpective.lookAt(0,0,0);
cameraPerpective.position.set(0,-100,100);


cameraOrthograpic = new THREE.OrthographicCamera( -100, 100, -100,100, 1, 1000);
scene.add(cameraOrthograpic);
cameraOrthograpic.up.set(0,0,1);
cameraOrthograpic.lookAt(0,0,0);
cameraOrthograpic.position.set(0,-100,100);

OBControls = new OrbitControls( cameraPerpective, renderer.domElement );
//OBControls.listenToKeyEvents( window ); // optional

//FPControls = new FirstPersonControls(camera1, renderer.domElement);
flyControls = new FlyControls(cameraOrthograpic,renderer.domElement);
//tbControls = new TrackballControls(cameraOrthograpic,renderer.domElement);



  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.SpotLight(color, intensity);
    light.position.set(0,0,100);
    scene.add(light);
  }

  {
  const color = 0xFFFFFF;  // white
  const near = 10;
  const far = 50;
  scene.fog = new THREE.Fog(color, near, far);
}

 
}

function main(){
  createMarks(scene,1,4,100);
 

  requestAnimationFrame(render);
}

function createMarks(scene, size, distance, number){
  const material = new THREE.LineBasicMaterial({
	color: 0xffffff
});

const points = [];
points.push( new THREE.Vector3( - size/2, 0, 0 ) );
points.push( new THREE.Vector3( size/2, 0, 0 ) );

const lineGeometry = new THREE.BufferGeometry().setFromPoints( points );

const horizontalLine = new THREE.Line( lineGeometry, material );
const verticalLine = horizontalLine.clone();
verticalLine.rotation.z = Math.PI/2;

const cross = new THREE.Group();
cross.add(horizontalLine);
cross.add(verticalLine);

const length = (number-1)*(size+distance);
for (let i=-length/2;i<=length/2;i=i+distance+size){
  for(let j=-length/2;j<=length/2;j=j+distance+size){
    const mark = cross.clone();
    scene.add(mark);
    mark.position.set(i,j,0);
  }  
}
}

function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }
  
function render(time) {
  //time *= 0.0004;
  const deltaTime = time-lastTime;
  lastTime = time;
  const interval = 4;
  

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      cameraPerpective.aspect = canvas.clientWidth / canvas.clientHeight;
      cameraPerpective.updateProjectionMatrix();
    }
    
  renderer.setScissor(0,0, window.innerWidth / 2, window.innerHeight );
  renderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight );
  renderer.render(scene, cameraPerpective);


  renderer.setScissor(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
  renderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
  renderer.render(scene, cameraOrthograpic);
    
   
    flyControls.update(deltaTime*0.05);
    //FPControls.update(deltaTime*0.05);
    //tbControls.update();

   
    requestAnimationFrame(render);
  }

</script>
</html>